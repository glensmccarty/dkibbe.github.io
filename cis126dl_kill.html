<h1 id="killing-a-run-away-process">Killing a Run Away Process</h1>

<p>Sometimes a process can get out of hand and drain system resources. It’s important to identify a run away process and terminate it. In this assignment you will start a process to drive up CPU usage and than use various command line tool to identify and terminate the run away process.</p>



<h2 id="commands-and-terms-you-should-know">Commands and Terms You Should Know</h2>

<ul>
<li><strong>Process:</strong> “A computer program in action”</li>
<li><strong>&amp;:</strong> An Ampersand following a command put the command in the background.</li>
<li><strong>jobs:</strong> List jobs running in the background.</li>
<li><strong>fg:</strong> Bring a back-grounded job to the foreground.</li>
<li><strong>PID:</strong> Process ID</li>
<li><strong>ps:</strong> Displays static information about processes.</li>
<li><strong>ptree:</strong> Displays a hierarchical view of processes.</li>
<li><strong>top:</strong> Provides a dynamic real-time view of a running system.</li>
<li><strong>htop:</strong> An interactive process view that allows scrolling.</li>
<li><strong>init:</strong> init is the parent of all processes on the system.</li>
<li><strong>nice:</strong> Run a program with modified scheduling priority.</li>
<li><strong>renice:</strong> Alter priority of a running process.</li>
<li><strong>kill:</strong> Terminate a running process.</li>
<li><strong>signal:</strong> Linux supports standard signals (SIGTERM, SIGKILL). See Resources below.</li>
</ul>



<h2 id="preparation">Preparation</h2>

<p>This lab can be done on any virtual machine.</p>



<h2 id="process-states">Process States</h2>

<p>As a process executes it changes state according to its circumstances. Linux processes have the following states:</p>

<ul>
<li><strong>Running:</strong> The process is either running (it is the current process in the system) or it is ready to run (it is waiting to be assigned to one of the system’s CPUs).</li>
<li><strong>Waiting:</strong> The process is waiting for an event or for a resource. Linux differentiates between two types of waiting process; interruptible and uninterruptible. Interruptible waiting processes can be interrupted by signals whereas uninterruptible waiting processes are waiting directly on hardware conditions and cannot be interrupted under any circumstances.</li>
<li><strong>Stopped:</strong> The process has been stopped, usually by receiving a signal. A process that is being debugged can be in a stopped state. </li>
<li><strong>Zombie:</strong> This is a halted process whose parent died before it finished. A zombie process will be taken over by <code>init</code> and terminated.</li>
</ul>



<h2 id="a-cpu-hog">A CPU Hog</h2>

<p>To simulate a runaway process redirect <em>/dev/zero</em> which outputs an endless stream of zeros to <em>/dev/null</em> which is a black hole. </p>

<pre><code>    $ cat /dev/zero &gt;/dev/null
</code></pre>



<h3 id="monitor-the-process">Monitor the process</h3>

<p>Open a new terminal and run the <code>top</code> command to see that the script is hogging CPU cycles.</p>

<p><img src="https://wm.sdf.org/gallery/albums/userpics/10081/top-cpuhog.jpg" alt="top" title="cpuhog script running in top"></p>



<h2 id="die-process-die">Die, Process, Die!</h2>



<h2 id="getting-the-correct-pid">Getting the Correct PID</h2>

<p>The first step to killing a run away process is to identify the Process ID. Use the <code>ps</code> command to identify the PID. <em>The PID number will be unique to your system.</em></p>

<p><img src="https://wm.sdf.org/gallery/albums/userpics/10081/ps-cpuhog.jpg" alt="ps" title="cpuhog script running in ps"></p>



<h3 id="hes-dead-jim">“He’s dead, Jim</h3>

<pre><code>    $ kill pid_number
</code></pre>

<p>You should see the process disappear from the <code>top</code>.</p>



<h3 id="sigterm">SIGTERM</h3>

<p>The <code>kill</code> command sends the <em>SIGTERM 15</em> signal to the process asking it to terminate and clear up any temporary files.</p>



<h3 id="sigkill">SIGKILL</h3>

<p>You can also send the more powerful <em>SIGKILL 9</em> signal which kills the process if it doesn’t respond to  SIGTERM.</p>

<pre><code>    $ kill -9 pid_number
</code></pre>

<p>Use <em>SIGKILL</em> only as a last resort since it can leave temporary behind.</p>



<h2 id="zombies">Zombies!</h2>

<p>Download this <a href="http://dennisk.freeshell.org/zombie" title="A program to create zombies">small C program</a> to create zombie processes.</p>

<p>Make the program executable and run it from the command line.</p>

<pre><code>    $ chmod +x zombies
    $ ./zomie
</code></pre>

<p>Use the techniques you used above to find and remove the zombie process.</p>



<h2 id="what-to-submit">What to Submit</h2>

<p>Submit a screenshot of the <em>/dev/zero &gt; /dev/null</em> process running in <code>top</code>.</p>



<h2 id="resources">Resources</h2>

<ul>
<li>man init</li>
<li>man 7 signal</li>
<li>man ps</li>
<li><a href="http://www.tldp.org/LDP/tlk/kernel/processes.html" title="The Linux Kernel">The Linux Kernel</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/58e72888-6340-46ac-b488-d31aa4058e9c/entry/an_overview_of_linux_processes21?lang=en" title="An Overview of Linux Processes">An Overview of Linux Processes</a></li>
<li><a href="http://dennisk.freeshell.org/zombie" title="A program to create zombies">A small C program to create zombie processes</a></li>
<li><a href="https://www.youtube.com/watch?v=g3JGItKPT8g" title="White Zombie (1932)">White Zombie (1932)</a></li>
</ul>



<h2 id="creative-commons-license">Creative Commons License</h2>

<p><a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" alt="Creative Commons License" title=""></a> <br>
This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p>